package neo4j.cypher.intentions;

/*Generated by MPS */

import jetbrains.mps.intentions.BaseIntention;
import jetbrains.mps.intentions.Intention;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptPropertyOperations;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;
import neo4j.cypher.behavior.IWriteStatement_Behavior;

public class IWriteStatementGrouping_Intention extends BaseIntention implements Intention {
  private static Logger LOG = Logger.getLogger(IWriteStatementGrouping_Intention.class);

  public IWriteStatementGrouping_Intention() {
  }

  public String getConcept() {
    return "neo4j.cypher.structure.IWriteStatement";
  }

  public boolean isParameterized() {
    return false;
  }

  public boolean isErrorIntention() {
    return false;
  }

  public boolean isAvailableInChildNodes() {
    return false;
  }

  public String getDescription(final SNode node, final EditorContext editorContext) {
    return "Groups common write statements together";
  }

  public boolean isApplicable(final SNode node, final EditorContext editorContext) {
    if (!(this.isApplicableToNode(node, editorContext))) {
      return false;
    }
    return true;
  }

  public boolean isApplicableToNode(final SNode node, final EditorContext editorContext) {
    return SConceptOperations.isSubConceptOf(SNodeOperations.getConceptDeclaration(node), "neo4j.cypher.structure.IWriteStatement");
  }

  public void execute(final SNode node, final EditorContext editorContext) {
    final Wrappers._T<SNode> beforeNode = new Wrappers._T<SNode>(null);
    final Wrappers._T<SNode> firstOfGroup = new Wrappers._T<SNode>(null);

    ListSequence.fromList(SNodeOperations.getDescendants(SNodeOperations.getAncestor(node, "neo4j.cypher.structure.QueryExpression", false, false), "neo4j.cypher.structure.IWriteStatement", false, new String[]{})).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        LOG.info("iwrite node:" + SConceptPropertyOperations.getString(SNodeOperations.getConceptDeclaration(it), "alias") + " idx:" + SNodeOperations.getIndexInParent(it) + " fq concept name:" + INamedConcept_Behavior.call_getFqName_1213877404258(SNodeOperations.getConceptDeclaration(it)));
        if (beforeNode.value != null) {
          if (INamedConcept_Behavior.call_getFqName_1213877404258(SNodeOperations.getConceptDeclaration(beforeNode.value)).equals(INamedConcept_Behavior.call_getFqName_1213877404258(SNodeOperations.getConceptDeclaration(it)))) {
            LOG.info("yes the same types");

          } else {
            LOG.info("first of group of the same type");
            firstOfGroup.value = it;
          }
        }
        beforeNode.value = it;

        // grouping starts we group all next group nodes to firstOfGroup node 
        if ((firstOfGroup.value != null) && firstOfGroup.value != it) {
          LOG.info("grouping");
          IWriteStatement_Behavior.call_joinWithTheSameNodeType_8020740480872452998(firstOfGroup.value, it);
          SNodeOperations.deleteNode(it);
        }
      }
    });
  }

  public String getLocationString() {
    return "neo4j.cypher.intentions";
  }
}
